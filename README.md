# shellcode

This repository contains some programming exercises on how write shellcode using Visual C++ Community Edition.
The idea came long times ago, working on a code-base where inline assembly was used for 32-bit cpu target, complicating code maintenance, and a few week ago I've picked up this topic again while I was talking with a friend's colleague.


Obviously we cannot compare the output generated by `cc` with the output generated writing a shellcode directly in assembly language, but as prototypes it is much easier and faster to make them.  

In the amd64 (x64) architecture this is so much easier, because all references are [Position-independent code](https://en.wikipedia.org/wiki/Position-independent_code).
The same can be achieved on x86 architecture, but it requires some precatuions in writing the code.

Example:
```cpp
printf("Hello world!");
```

Output generated for both architectures:
|offset|x86|amd64|
|------|---|-----|
| 00 | mov eax, offset HelloWorld | lea rcx, offset HelloWorld |
| 05 | push eax | |
| 06 | call printf | |
| 08 | | call printf |
| 10 | printf: .... | printf: .... |
| 80 | db 'Hello World' | db 'Hello World' |

Considering as Base Address 0x1000, and the string 'Hello World' located at 0x1000+0x80, on 32-bit address the image generated by the compiler will contains the full address of a string, because the instruction [`LEA`](https://www.felixcloutier.com/x86/lea) takes as src an address of memory, a register, or a register+offset (register, register+offset are equivalents of `mov dst, src`, or `mov dst, src add dst, imm8/16/32`).

On 64-bit, all variables (globals, as functions, constants, r/w variables) can be accessed via RIP (64-bit Instruction pointer) and their address is expressed as:

`ADDRESSOF(SYMBOL) - CURRENT_INSTRUCTION + sizeof(CURRENT_INSTRUCTION)`

In this way, we don't need to known our shellcode position, we don't need anymore the `call 0 pop eax` to get our base address and to reference the memory as result of our base address + offset in the generated file.

On 32-bit this is not possible, so the simple way is to use only stack variables or to attach our readonly variables to the shellcode and using an `egg-hunter` to get the address of this block of data and to access af it were a data structure (so base address plus offset for every element).

Examples available:  
    - `spawncalc` -> execute `%SYSTEM32%\calc`

Function availables:  
- `wcslen`:   Return the number of chars inside a unicode string (must be null terminated);
- `strlen`:   Return the number of chars inside a ascii string (must be null terminated);
- `_wcsrchr`: Return NULL or the first occurrence from right-side of _Ch into _Str. The original function is wcsrchr, but Windows.h includes some CRT components where wcsrchr is defined;
- `memset`: An example of instrinsic instruction available with MSVC. Using REP STOSB, the memory starting from _Dst is replaced with _Val for _Size bytes;
- `memcmp`: Compare two block of memory
- `strcmp`: Compare two ascii strings;
- `wstrcmp`: Compare a wide string with an ascii string;
- `getModuleHandle`: Retrieve the HMODULE of a DLL loaded in memory walking in PEB LDR DATA.
- `WinMain`: the entry point

***C++ Compiler Settings***:
```
    Enable C++ Exceptions: No
    Runtime Library: Multi-threaded (/MT)
    Security Check: Disable Security Check (/GS-)
```

***Linker Settings***:
```
    Ignore All Default Libraries: Yes (/NODEFAULTLIB)
    SubSystem: Windows (/SUBSYSTEM:WINDOWS)
    Function Order: order.txt
    Entry Point: WinMain (without standard libraries, there is no WinMainCRTStartup).
```

## Security check
You can find informations about `/GS` parameter [here](https://learn.microsoft.com/en-us/cpp/build/reference/gs-buffer-security-check?view=msvc-170)
It's necessary to disable `/GS` (`/GS-`) or we should provide all missing symbols used by the compiler in the prologue/epilogue of every function.

## Runtime Library
The static Runtime Library (Multi-threaded, Multi-threaded Debug) contains MSVCRT code to initialize the process, to invoke the Main Function, to manage the heap and provide also a thread-safe malloc/free primitives.

## Ignore All Default Libraries
Using this flag, we are telling the compiler we don't want any standard library. Removing standard libraries, function likes malloc, strlen, free etc.. are not available.
It will be our responsability to provide them, but at same time we can avoid injection of useless function for us.

## Function Order
When an object file is generated, the function usually are sorted in the same way they appear. Tipically, the main function is the latest function we are going to declare, but we can
specify the order of how the function will be sorted in the final image. We are not interested to tell the compiler all the function, but we are interested to be sure our entry point (in this case the WinMain) is the first function present in the text, so as shellcode, it will jump directly in our main function.


## getModuleHandle

GetModuleHandle find in the PEB LDR DATA structure a module in a linked list.

Using windbg you can load an x64 file (or 32bit) and you'll find the same data with the following commands:
```windbg
0:000> !peb
PEB at 0000001389a77000
    InheritedAddressSpace:    No
    ReadImageFileExecOptions: No
    BeingDebugged:            Yes
    ImageBaseAddress:         00007ff7030d0000
    NtGlobalFlag:             0
    NtGlobalFlag2:            0
    Ldr                       00007ffe21f94380
    Ldr.Initialized:          Yes
    Ldr.InInitializationOrderModuleList: 000001473fd024c0 . 000001473fd07360
    Ldr.InLoadOrderModuleList:           000001473fd02640 . 000001473fd0f310
    Ldr.InMemoryOrderModuleList:         000001473fd02650 . 000001473fd0f320
                    Base TimeStamp                     Module
            7ff7030d0000 e798efb4 Feb 15 19:08:52 2093 C:\Windows\System32\notepad.exe
            7ffe21e10000 6cf39caa Dec 04 08:18:02 2027 C:\Windows\SYSTEM32\ntdll.dll
            7ffe21b60000 697746c7 Jan 26 11:49:43 2026 C:\Windows\System32\KERNEL32.DLL
            7ffe1f810000 f9b807f0 Oct 06 16:17:20 2102 C:\Windows\System32\KERNELBASE.dll
            7ffe21470000 cd85c33b Apr 07 14:19:07 2079 C:\Windows\System32\GDI32.dll
            7ffe1f250000 c3654010 Nov 18 02:04:16 2073 C:\Windows\System32\win32u.dll
            7ffe1f6f0000 4b8bab26 Mar 01 12:55:18 2010 C:\Windows\System32\gdi32full.dll
            7ffe1f650000 594521c3 Jun 17 14:34:11 2017 C:\Windows\System32\msvcp_win.dll
            7ffe1f530000 f5fc15a3 Oct 11 13:48:51 2100 C:\Windows\System32\ucrtbase.dll
            7ffe1fc20000 116ee73d Apr 09 06:40:29 1979 C:\Windows\System32\USER32.dll
            7ffe20c70000 a0fb7b18 Aug 02 18:06:48 2055 C:\Windows\System32\combase.dll
            7ffe1ff50000 31c548ed Jun 17 14:00:45 1996 C:\Windows\System32\RPCRT4.dll
            7ffe21cd0000 0d62b963 Feb 12 06:36:35 1977 C:\Windows\System32\shcore.dll
            7ffe21550000 7c6f10cc Feb 26 16:46:20 2036 C:\Windows\System32\advapi32.dll
            7ffe20140000 c4d8152c Aug 26 09:52:12 2074 C:\Windows\System32\msvcrt.dll
            7ffe214a0000 95072b73 Mar 25 09:50:59 2049 C:\Windows\System32\sechost.dll
            7ffe08800000 620af90b Feb 15 01:51:23 2022 C:\Windows\WinSxS\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.22621.317_none_a9434687c10c9fa2\COMCTL32.dll
```

Via the Ldr.InMemoryOrderModuleList, we can access to _LDR_DATA_TABLE_ENTRY structure.. so
```windbg
0:000> dt ntdll!_LDR_DATA_TABLE_ENTRY 000001473fd02650 
 +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000147`3fd024b0 - 0x00007ffe`21f943a0 ]
   +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ]
   +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x00007ff7`030d0000 - 0x00007ff7`030d19a0 ]
   +0x030 DllBase          : 0x00000000`0005a000 Void
   +0x038 EntryPoint       : 0x00000000`0040003e Void
   +0x040 SizeOfImage      : 0x3fd07010
   +0x048 FullDllName      : _UNICODE_STRING "notepad.exe"
   +0x058 BaseDllName      : _UNICODE_STRING "???"
```

As you can see, the member InInitializationOrderLinks doesn't contain a real linked list, but the Image Base address in in memory.

## Data
Strings are allocated in `.text` section using MSVC directives
```cpp
#pragma code_seg(".text")

__declspec(allocate(".text"))
type name[] = value;
```

Telling the compiler to allocate the data directly in `.text` section, it's enough to export the section code to get a complete shellcode.
To be sure everything is fine, you can use IDA Disassembler to check if there is nothing referenced outside this section, or you must export the data from other section and append to your shellcode (obviously fixing the offset used with LEA or MOV instructions).

# Improvements
If you want to improve this solution (may because you don't want to expose the API are you using etc.) instead of using strings for GetModuleHandle/GetProcAddress, you can replace them using any hash function, and it's enough to replace the `strcmp` call inside `getProcAddress` routine with your hash function and compare the return value to the expected hash.

Also, based on how your code is triggered (a new thread, an exploit of vulnerability or whatever) an analysis of the context can be helpful to avoid to access to the PEB directly,
because manipulating directly the data structure can trigger an EDR which eventually applied some protection to the PEB address.

# How To Build
Using VS C++ (Community Edition) you can build this sample. Double click on `shellcode.sln`, Choose `x64|Release` and build all.

From command line (developer prompt): `nmake`

## Optimization
Keep in mind your shellcode written in C can grow quite quickly, and the compiler will follow the SUBSYSTEM requirements (function aligned, stack reservation etc.). On a 32-bit application you can benefit of naked function and inline assembly, forbidden on x64 (which eventually will requires an extra file of functions written in assembly where the instric are not enough).

Think to `memset` instruction, which can be expressed in assembly as:
```asm
push rdi
mov rdi, rcx
mov rax, rdx
mov rcx, r8
rep stosb
pop rdi
ret
```

The same function, generated by the compiler is:
```asm
mov     [rsp+18], r8                ; size
mov     [rsp+10], edx               ; pattern
mov     [rsp+8], rcx                ; destination
push    rdi
mov     rdi, [rsp+8+8]              ; load dst in rdi
movzx   eax, byte ptr [rsp+8+10]    ; load pattern in eax
mov     rcx, [rsp+8+18]             ; load size in rcx
rep stosb                           ; repeat stosb (store a byte in es:[edi]) until ecx != 0
mov     rax, [rsp+8+8]              ; rax = dst
pop     rdi
ret
```

Another consideration is related to strings (wcslen, strlen). Technically, the difference between a strlen and a wcslen is just the element size, and instead of having a strlen and a wcslen (basically same function, with a add reg, 2 for wcslen and inc reg for strlen), both function can be merged in a single function with an extra argument for the size like:

```cpp
length(ptr, sizeof(char)); // strlen
length(ptr, sizeof(wchar_t)); // wcslen
```

and `wcscmp` and `strcmp` can be replaced with a simple memcmp with the length in bytes of the string.
